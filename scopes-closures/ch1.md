# You Don't Know JS Yet: Області видимості та замикання - Друге видання
# Розділ 1: Що таке область видимості?

Ті з вас, хто вже написав бодай кілька програм, скоріш за все досить впевнено створюють змінні та зберігають значення у них. Робота зі змінними — це одна з фундаментальних речей у програмуванні!

Але чи замислювалися ви колись над механізмом, який використовує рушій для організації та управління змінними? Я зараз не про виділення пам'яті у комп'ютері. Моє питання ось у чому: як JS знає, які змінні доступні певній інструкції, і як він обходиться з двома змінними на одне ім'я (з однаковим ім'ям)?

Для відповіді на подібні питання необхідна певна форма визначених правил, що називається областю видимості. Ця книга пройде усі аспекти областей видимості — як вони працюють, для чого потрібні, розгляне ситуації, яких варто уникати, а потім наведе загально використовувані шаблони роботи з областями видимості, що керують структурами програм. 

Нашим першим кроком буде розібратися з тим, як JS-рушій опрацьовує програму **до** того, як почне її виконувати.

## Про цю книгу

Ласкаво просимо до другої книги з серії *You Don't Know JS Yet*! Якщо ви вже закінчили першу книгу *Get Started*, то ви у вірному місці. Якщо ні, то я рекомендую почати звідти.

Ми зосередимося на першій з трьох опор JS: на системі областей видимості та замикання функцій, а також поговоримо про силу шаблону проєктування "Модуль".

JS, як правило, класифікують як інтерпретовану скриптову мову, тому більшість припускають, що програми на JS обробляються за один прохід зверху вниз. Та насправді програми на JS перед виконанням проходять окрему стадію парсинга та компіляції. Під час цієї фази аналізуються рішення автора коду щодо розміщення змінних, функцій та блоків відносно один одного згідно з правилами створення областей видимості. Зазвичай створена структура областей видимості не змінюється під час виконання (у рантаймі).

Функції у JS — значення першого класу: їх можна присвоювати у змінні та передавати, як числа або рядки. Але через те, що функції містять власні змінні та мають доступ до змінних ззовні, вони зберігають власну початкову область видимості, бодай де в програмі функція виконуватиметься. Це називається замикання.

Модулі — це шаблон організації коду, що характеризується публічними методами, які через замикання мають привілейований доступ до прихованих змінних та функцій у внутрішній області видимості модуля.

## Компіляція проти інтерпретації

Можливо, ви вже чули про компіляцію коду, але також цілком можливо, що цей процес здається загадковою чорною скринькою, що проковтує вихідний код та видає придатну до виконання програму.

Однак нічого загадкового або магічного у компіляції немає. Компіляція коду — це набір кроків, що обробляють текст вашого коду та перетворюють його на список інструкцій, зрозумілих комп'ютеру. Зазвичай весь вихідний код трансформується за один раз, а інструкції, що створюються на виході, зберігаються як в певному вигляді (зазвичай у файлі), що може бути виконаний.

Також ви могли чути про те, що код можна інтерпретувати. Чим це відрізняється від компіляції?

Інтерпретація коду подібна до компіляції у тому сенсі, що інтерпретація також перетворює програму на інструкції, зрозумілі машині. Але інтерпретація відрізняється від компіляції моделлю обробки коду. На відміну від компіляції, що обробляє усю програму за раз, інтерпретація трансформує вихідний код рядок за рядком. Кожен рядок або інструкція одразу виконуються, після чого інтерпретатор переходить до наступного рядка.

<figure>
    <img src="images/fig1.png" width="650" alt="Code Compilation and Code Interpretation" align="center">
    <figcaption><em>Fig. 1: Compiled vs. Interpreted Code</em></figcaption>
    <br><br>
</figure>

Рисунок 1 ілюструє компіляцію та інтерпретацію програм.

Чи ці моделі повністю виключають одна одну? Зазвичай так. Але проблема трохи складніша, бо інтерпретація може приймати інші форми, ніж обробка рядків вихідного коду один за одним. Сучасні рушії використовують для роботи з програмами на JS численні варіація як компіляції, так і інтерпретації.

Згадайте, що при торкалися цієї теми у розділі 1 книги *Get Started*. Наш висновок тоді був такий, що найбільш точним буде описувати JS як компільовану мову. Наступний розділ перегляне та розширить це твердження.

## Компіляція коду

Для початку розберемося з тим, яке значення має те, чи є JS компільованою чи інтерпретованою мовою.

Області видимості визначаються під час компіляції, тому зв'язок між компіляцією та виконанням є ключовим моментом у розумінні областей видимості.

У класичній теорії компіляторів програма обробляється компілятором за три стадії:

1. **Токенізація чи лексичний аналіз** - це розбиття рядка символів на фрагменти, що мають сенс для певної мови. Ці фрагменти називаються токенами. Наприклад, візьмемо програму `var a = 2;`. Ймовірно цю програму буде розбито на токени наступним чином: `var`, `a`, `=`, `2`, та `;`. Символ пробілу може бути або не бути токеном залежно від того, чи він впливає на значення.


    Різниця між токенізацією та лексичним аналізом досить тонка та представляє інтерес скоріш в академічному контексті; найбільш важливим аспектом є те, чи ідентифікуються токени зі збереженням стану. Простіше кажучи, якщо токенізатор використовуватиме правила парсингу зі збереженням стану, щоб дізнатися, чи `a` слід вважати окремим токеном або частиною іншого токену, то це буде лексичним аналізом.

2. **Парсинг** перетворює потік (масив) токенів на дерево вкладених елементів, які разом представляють граматичну структуру програми. Ця структура називається абстрактним синтаксичним деревом (АСД).

    Наприклад, для `var a = 2;` дерево може починатися з вузла найвищого рівня, що називається `VariableDeclaration`, із дочірніми вузлами `Identifier`, що має значення `a`, та `NumericLiteral`, що має значення `2`.

3. **Генерація коду** перетворює АСД на код, що може бути виконаний. Ця частина сильно залежить від мови, платформи виконання та інших факторів.

    Рушій JS перетворює щойно описане АСД для `var a = 2;` на набір машинних інструкцій, що врешті решт створять змінну на ім'я `a`, з урахуванням резервування пам'яті й так далі, а потім збережуть у ній значення.

| ПРИМІТКА: |
| :--- |
| Реалізації рушія JS, зокрема використання системних ресурсів пам'яті, насправді значно складніша. Ми зосередимо увагу на видимій поведінці програми та залишимо управління цими глибокими системними абстракціями за рушієм |

Рушій JS значно складніший за ті три фази, що ми описали. В процесі парсингу та генерації коду вживаються міри до оптимізації ефективності виконання, наприклад прибираються зайві елементи. Насправді код навіть може бути компільований повторно або повторно оптимізований під час виконання.

Отже, я окреслюю лише загальну картину. Але скоро ви побачите, чому *ті деталі, яких ми торкаємося*, навіть дуже поверхнево, мають значення.

У порівнянні з іншими мовами рушії JS мають небагато часу для виконання своєї основної роботи та проведення оптимізації, бо компіляція JS не виконується завчасно. Зазвичай процес обробки коду має відбуватися безпосередньо перед його виконанням та тривати лічені мікросекунди (чи навіть менше!). Щоб забезпечити найкращу швидкодію за цих обмежень, рушії JS вдаються до усіляких хитрощів (наприклад, JIT - компіляція «на льоту», яка ліниво* компілює і навіть перекомпілює код під час виконання); подробиці таких оптимізацій виходять за рамки нашої теми.

### Необхідна умова: Дві фази

Щоб висловити це якомога простіше, найважливішим зауваженням, яке ми можемо зробити щодо обробки програм JS, є те, що вона складається принаймні з двох фаз: спочатку парсинг і компіляція, потім виконання.

Те, що фаза парсингу або компіляції відокремлена від фази виконання, не припущення і не особиста думка, а факт, який ви можете побачити на власні очі. Хоча специфікація JS явно не вимагає "компіляції", вона все ж вимагає поведінки, яка, по суті, є практичною лише за умови виконання коду після завершення компіляції.

Існує три видимі характеристики програми, які доводять моє твердження: синтаксичні помилки, ранні помилки та підняття змінних (hoisting).

#### Синтаксичні помилки видно одразу

Розглянемо таку програму:

```js
var greeting = "Hello";

console.log(greeting);

greeting = ."Hi";
// SyntaxError: unexpected token .
```

Ця програма не видає жодних результатів (`"Hello"` не виводиться). Замість цього виникає помилка `SyntaxError` через несподіваний токен `.` безпосередньо перед рядком `"Hi"`. Оскільки синтаксична помилка знаходиться після добре сформованої інструкції `console.log (..)`, можна було б очікувати, що при виконанні коду рядок за рядком зверху вниз перед появою синтаксичної помилки буде виведено повідомлення `"Hello"`. Але цього не відбувається.

Насправді єдиний спосіб, в який рушій JS міг дізнатися про синтаксичну помилку у третьому рядку до того, як виконав перший та другий, — це розпарсити всю програму перед виконанням будь-якої її частини.

#### Ранні помилки

Наступний приклад:

```js
console.log("Howdy");

saySomething("Hello","Hi");
// Uncaught SyntaxError: Duplicate parameter name not
// allowed in this context

function saySomething(greeting,greeting) {
    "use strict";
    console.log(greeting);
}
```

Повідомлення `"Howdy"` не виводиться, попри те, що це коректно сформована інструкція.

Натомість подібно до фрагмента коду з попереднього розділу, до початку виконання програми виводиться помилка `SyntaxError`. У цьому випадку суворий режим виконання (strict mode), який ми активували лише для функції `saySomething(..)`, серед іншого, забороняє функції мати однойменні параметри. У несуворому режимі це завжди було дозволено.

Помилка не синтаксична у тому сенсі, що код неправильно сформований, як `."Hi"` у попередньому прикладі, але згідно до специфікації у суворому режимі таку помилку має бути викинуто як ранню помилку ("early error") до початку виконання коду.

Але звідки рушій JS знає, що параметр `greeting` дублюється? Звідки він знає під час обробки списку параметрів, що функція `saySomething(..)` виконується у суворому режимі, адже прагма `"use strict"` з'являється пізніше, у тілі функції?

Повторю: єдине розумне пояснення у тому, що код було розпарсено перед виконанням.

#### Підняття змінних (Hoisting)

Насамкінець давайте розглянемо такий код:

```js
function saySomething() {
    var greeting = "Hello";
    {
        greeting = "Howdy";  // error comes from here
        let greeting = "Hi";
        console.log(greeting);
    }
}

saySomething();
// ReferenceError: Cannot access 'greeting' before
// initialization
```

Помилка `ReferenceError` з'являється на рядку, де знаходиться інструкція `greeting = "Howdy"`. Річ у тому, що змінна `greeting`, до якої звертається інструкція, належить до оголошення, що відбувається у наступному рядку `let greeting = "Hi"`, а не до попередньої інструкції `var greeting = "Hello"`.

Єдиний спосіб, у який рушій JS у рядку, де виникає помилка, може знати, що *наступна інструкція* оголосить змінну блокової області видимості з тим самим іменем (`greeting`), це якщо рушій вже обробив цей код у попередній прохід і вже визначив усі області видимості та пов'язані з ними змінні. Цю обробку областей і оголошень можна точно здійснити, лише проаналізувавши програму перед виконанням.

Суворо кажучи, `ReferenceError` з'являється в інструкції `greeting = "Howdy"`, яка звертається до змінної `greeting` зарано і провокує конфлікт, що називається "тимчасова мертва зона" (Temporal Dead Zone), скорочено ТМЗ. Ми розглянемо цю тему детальніше у розділі 5.

| УВАГА: |
| :--- |
| Часто стверджують, що змінні, оголошені через `let` та `const`, не підіймаються, і саме цим пояснюється ТМЗ. Але це не точно. Ми повернемось до підняття і ТМЗ `let` та `const` у розділі 5.|

Я сподіваюся, що переконав вас у тому, що JS-програми парсяться до того, як почнеться їхнє виконання. Але чи це доводить, що вони також компілюються?

Цікаве питання! Чи можливо, що JS парсить програму, а потім інтерпретує операції, представлені у вигляді АСТ, одну за одною, але не виконує попередню компіляцію? Так, це можливо. Але дуже малоймовірно, здебільшого через те, що це було б вкрай неефективно. 

Важко уявити собі якісний JS-рушій, що виконує складний парсинг програми в АСД, але не перетворює (тобто, не "скомпілює") АСД на найбільш ефективне для виконання бінарне представлення. 

Багато хто докладав зусиль до прояснення нюансів термінології, і тут їх справді чимало, але за духом та з практичної точки зору те, що робить JS-рушій, скоріш схоже на компіляцію, ніж ні.

Коли ми відносимо JS до компільованих мов, ми маємо на увазі не спосіб розповсюдження бінарного представлення, а те, що треба мати на увазі фазу, під час якої проходить обробка та аналіз JS-коду. Ми легко можемо переконатися у тому, що ця фаза передує початку виконання коду.

Якщо ми хочемо добре зрозуміти області видимості, нам потрібна належна ментальна модель того, як рушій JS обходиться з нашим кодом.

## Жаргон компілятора

Тепер, коли ми знаємо про двофазну обробку JS-програми (спочатку компіляція, потім виконання), звернімо увагу на те, як рушій  під час компіляції знаходить змінні та визначає області видимості програми.

Почнемо з простої програми на JS, яку ми використовуватимемо як приклад для кількох наступних розділів:

```js
var students = [
    { id: 14, name: "Kyle" },
    { id: 73, name: "Suzy" },
    { id: 112, name: "Frank" },
    { id: 6, name: "Sarah" }
];

function getStudentName(studentID) {
    for (let student of students) {
        if (student.id == studentID) {
            return student.name;
        }
    }
}

var nextStudent = getStudentName(73);

console.log(nextStudent);
// Suzy
```

За винятком оголошень, змінних або ідентифікатори у програмі виконують одну з двох "ролей": вони є або *ціллю* призначення, або *джерелом* походження значення.

(Коли я був студентом фаху Computer Science та тільки вивчав теорію компіляторів, нас навчили термінів "LHS" (відповідає *цілі*) і "RHS" (відповідає *джерелу*). Як ви могли здогадатися за літерами "L" та "R", ці абревіатури означають "Ліва сторона" та "Права сторона". Мається на увазі ліворуч або праворуч від оператора присвоєння `=`. Однак цілі призначення та джерела не завжди знаходяться буквально ліворуч або праворуч від `=`, тому, мабуть, простіше мислити термінами *ціль* та *джерело*, а не *ліворуч* та *праворуч*.)

Як дізнатися, чи є змінна *ціллю*? Перевірте, чи їй присвоєне значення; якщо так, то це *ціль*. Якщо ні, тоді змінна є *джерелом*.

Щоб рушій JS правильно обробляв змінні програми, він повинен спочатку позначити кожну появу змінної як *ціль* або *джерело*. Зараз ми розглянемо, як визначається ця роль.

### Цілі

Що робить змінну *ціллю*? Розглянемо:

```js
students = [ // ..
```

Ця інструкція явно є операцією присвоєння; згадайте, що фрагмент `var students` обробляється як оголошення під час компіляції, отже, під час виконання не має значення; для ясності та зосередженості ми його пропустили. Те саме стосується інструкції `nextStudent = getStudentName (73)`.

Але в коді є ще три операції присвоєння *цілі*, які, мабуть, менш очевидні. Одна з них:

```js
for (let student of students) {
```

Ця інструкція на кожній ітерації циклу присвоює змінній `student` нове значення. Ще одне *цільове* посилання:

```js
getStudentName(73)
```

Але чому ми говоримо про *ціль* у цьому випадку? Подивіться уважно: аргумент `73` присвоюється параметру `studentID`.

В нашій програмі є ще одне найнепомітніше *цільове* посилання. Бачите?

..

..

..

Чи помітили ви оце?

```js
function getStudentName(studentID) {
```

Оголошення `function` є особливим випадком посилання на ціль. Ви можете думати про нього як `var getStudentName = function(studentID)`, але це не зовсім точно. Ідентифікатор `getStudentName` оголошується під час компіляції, але і фрагмент `= function (studentID)` також обробляється під час компіляції; зв'язок між `getStudentName` і функцією автоматично встановлюється на початку області видимості, рушій не чекає на виконання оператора присвоєння `=`.

| ПРИМІТКА: |
| :--- |
| Це автоматичне поєднання функції та змінної називається "підняттям функції". Детально воно висвітлене в розділі 5. |

### Джерела

Отже, ми визначили всі п’ять посилань типу *ціль* у програмі. Тоді інші посилання на змінну повинні бути *джерелами*, оскільки інших варіантів не лишилося.

Про `for (let student of students)` ми сказали, що `student` —  це *ціль*, але `students` —  це *джерело* посилання. В інструкції `if (student.id == studentID)`  `student` і `studentID` обидва є *джерелом* посилань. `student` також є посиланням на *джерело* у `return student.name`.

У `getStudentName (73)`, `getStudentName` є посиланням типу *джерело* (яке, як ми сподіваємось, перетворюється на значення посилання на функцію). У `console.log (nextStudent)`, `console` є посиланням на *джерело*, як і `nextStudent`.

| ПРИМІТКА: |
| :--- |
| Якщо вам цікаво, `id`,` name` та `log` —  це властивості, а не посилання на змінні. |

В чому практична цінність розуміння різниці між *цілями* та *джерелами*? У розділі 2 ми повернемося до цієї теми та розглянемо вплив ролі змінної на процес пошуку значення (особливо у тих випадках, коли значення не знайдене).

## Як обманути рушій: Модифікація області видимості під час виконання

На цей момент має бути зрозуміло, що області видимості визначаються під час компіляції програми та не залежать від умов рантайму. Але у несуворому режимі існує два способи порушити це правило завдяки зміні області видимості під час виконання.

Жодну з цих технік не рекомендована до використання, бо вони небезпечні та незрозумілі. Крім того, варто у будь-якому разі писати у суворому режимі, де ці техніки недоступні. Але про них важливо знати на випадок, якщо ви натрапите на них у коді інших розробників.

Функція `eval (..)` очікує рядок коду, який вона компілює на льоту та виконує під час роботи програми. Якщо в цьому рядку коду є декларація `var` або` function`, ці декларації змінять область видимості, в якій виконується `eval (..)`:

```js
function badIdea() {
    eval("var oops = 'Ugh!';");
    console.log(oops);
}
badIdea();   // Ugh!
```

Без `eval (..)` змінна `oops` у `console.log (oops)` не було і звернення до неї призвело б до появи помилки `ReferenceError`. Але `eval (..)` змінює область видимості функції `badIdea ()` під час виконання. Це погано з багатьох причин, не в останню чергу через погіршення швидкодії: щоразу при виклику `badIdea ()`  область видимості доводиться повторно компілювати та оптимізувати.

Другий спосіб обману — це ключове слово `with`, яке по суті динамічно перетворює об'єкт на локальну область видимості — його властивості розглядаються як ідентифікатори в новому блоці області:

```js
var badIdea = { oops: "Ugh!" };

with (badIdea) {
    console.log(oops);   // Ugh!
}
```

Глобальна область видимості не змінювалася, але  під час виконання, а не під час компіляції,  в області видимості виник об'єкт `badIdea` та його властивість `oops` стала змінною у цій області видимості. Ще раз нагадаю, що з точки зору швидкодії та простоти читання коду це погана ідея.

Уникайте `eval(..)` за будь-якої ціни  (принаймні `eval(..)`, що оголошує змінні) та `with`. Повторю, що жоден з цих інструментів не доступний у суворому режимі, тож, якщо ви використовуєте цей режим (а я вам дуже раджу це робити), то боротися зі спокусою вам не доведеться.

## Лексичні області видимості

Ми переконалися у тому, що області видимості у JS визначаються на момент компіляції. Області видимості такого типу називаються лексичними. Слово "лексичний" відсилає до lexing - лексичного аналізу під час компіляції, про який ми говорили раніше у цьому розділі.

Практичний висновок, який варто винести з цього розділу, такий: ключова ідея лексичної області видимості полягає у тому, що вона цілком залежить від взаємного розташування функцій, блоків та оголошень змінних.

Якщо ви розміщуєте оголошення змінної в тілі функції, компілятор обробляє це оголошення під час парсингу функції та поєднує це оголошення з областю видимості функції. Якщо змінна оголошена у блоці (з `let` / `const`), то вона прив'язується до найближчого блоку `{ .. }`, а не до функції (як було б із `var`)

Більш того, для кожного посилання на змінну (чи то ціль, чи то джерело) в одній з лексично досяжних областей видимості має бути знайдена відповідна змінна. Інакше змінна вважається не оголошеною, що зазвичай приводить до помилки. Якщо змінна не оголошена у поточній області видимості, перевіряється наступна, тобто та, що містить поточну. Цей процес переходу від одного рівня областей видимості до наступного продовжується, аж поки знаходиться відповідне оголошення змінної, або поки процес дістається глобальної області видимості й далі йти нікуди.

Важливо зауважити, що компіляція не резервує пам'ять під області видимості чи змінні. Жодна частина програми ще не виконується.

Натомість компіляція створює мапу усіх лексичних областей видимості, яка окреслює усе, що знадобиться програмі під час виконання. Ви можете дивитися на цю мапу як на код, який буде вставлений у програму під час виконання, та який визначає всі області видимості, також відомі як лексичні оточення, та реєструє  для кожної такої області всі ідентифікатори (змінні).

Іншими словами, області видимості визначаються під час компіляції, але створюються лише під час виконання, щоразу як область видимості виконується. У наступному розділі ми визначимо концептуальні основи лексичної області видимості.

* мається на увазі стратегія лінивих обчислень - https://en.wikipedia.org/wiki/Lazy_evaluation (прим.перекл.)

# Серія "Ти поки що не знаєш JS". Книга 1: "Почнемо!". Друге видання
# Глава 1: Що таке JavaScript?

Ти поки що не знаєш JS. Я теж ще ні. Принаймні, не знаю його досконально. І ніхто з нас не знає. Але всі ми можемо почати пізнавати JS краще.

У першій главі першої книги серії *Ти поки що не знаєш JS*(далі скорочено YDKJSY) ми витратимо трохи часу на те, щоб закласти підґрунтя для подальшого руху. Треба почати з огляду різноманітних важливих допоміжних знань та з розвіяння деяких міфів та хибних уявлень про те, чим мова є насправді, а чим — ні.

Йдеться про цінне розуміння того, як мова організована та підтримує своє існування; всім JS-розробникам варто мати це розуміння. Якщо ви хочете вивчити JS по-справжньому, саме з цього слід *розпочинати* вашу мандрівки.

## Про цю книгу

Я наголошую на слові "мандрівка", тому що *розуміння JS* - це не пункт призначення, це напрямок. Скільки б часу ви не проводили з мовою, ви завжди зможете знайти щось таке, чому можна навчитися чи зрозуміти глибше. Тож не дивіться на цю книгу як на таку, що потрібно прочитати якнайшвидше. Терпіння та наполегливість будуть найкращою допомогою  під час ваших початкових кроків.

Після першої довідкової глави в решті книги викладається огляд того, що на вас чекає, якщо ви вирішите вивчати JS із книгами YDKJSY.

Зокрема, глава 4 визначає три основні опори, навколо яких організована мова JS: області видимості та замикання, прототипи та об'єкти і типи та приведення типів. JS - широка та вишукана мова, що має безліч функцій та можливостей, але весь JS ґрунтується на цих трьох опорах.

Майте на увазі, що хоча ця книга називається "Почнемо!", вона **не призначена для початківців або для використання у якості першого підручника з JS**. Основна задача цієї книги - підготувати вас до глибокого вивчення JS з книгами решти серії; текст книги припускає, що ви вже маєте принаймні кілька місяців досвіду написання коду на JS. Тож, щоб отримати максимальну віддачу від *Почнемо!*, переконайтеся, що витратили достатньо часу на написання коду на JS та отримали свій досвід.

Якщо ви вже написали чимало JS-коду, цю книгу все одно не слід продивлятися неуважно або геть пропускати; виділіть достатньо часу на опрацювання цього матеріалу. **Для хорошого старту необхідний надійний перший крок.**

## А що з назвою?

Мабуть, "JavaScript" - це назва, що найчастіше серед мов програмування наводить на хибні думки чи уявлення.

Чи має ця мова відношення до Java? Це лише скриптова форма Java? Вона тільки для написання сценаріїв, тобто скриптів, а не справжніх програм?

Правда в тому, що назва JavaScript - це артефакт маркетингових хитрощів. Коли Брендан Ейх вперше задумав цю мову, він дав їй кодову назву Мокка. Для внутрішніх потреб в Netscape використовували бренд LiveScript, але коли прийшов час публічно назвати мову, переміг "JavaScript".

Чому? Бо мова від початку мала сподобатись аудиторії програмістів, що переважно писали на Java, а слово "скрипт"(тобто, "сценарій") було у той час популярним для позначення легких програм. Ці полегшені "сценарії" будуть першими, що вставлять всередину сторінок у цю нову штуку, що називається "Всесвітнє павутиння"!

Іншими словами, JavaScript був маркетинговим трюком, до якого вдалися, щоб позиціонувати цю мову як приємну альтернативу важчій та відомішій того часу Java. За цією логікою мова могла називатися, скажімо, "WebJava".

Між кодом на JavaScript і кодом на Java є деякі поверхневі подібності. Ці подібності походять не від спільного розвитку мов, а від того, що обидві мови орієнтовані на розробників, що звикли до мов з синтаксисом C (а також певною мірою C++).

Наприклад, ми ставимо `{` на початку блоку коду та `}` наприкінці, як у C чи C++ та Java. Також ми використовуємо `;` для закінчення інструкції.

Певним чином правовідносини між JS та Java сягають навіть глибше, ніж синтаксис. Компанія Oracle (через Sun), яка все ще володіє і керує Java, також (через Netscape) володіє офіційною торговою маркою "JavaScript". Ця торгова марка майже ніколи не застосовується і, напевно, не могла б на цю мить.

З цих причин дехто пропонує називати мову JS замість JavaScript. Це дуже поширене скорочення, і, можливо, хороший кандидат для офіційного бренду мови. Для посилання на мову у книгах цієї серії майже виключно використовується саме JS.

Щоб відмежувати мову від торгової марки, що належить Oracle, ще сильніше, офіційною назвою мови, визначеної TC39 та формалізованою організацією стандартизації ECMA, є **ECMAScript**. І справді, з 2016 року офіційна назва мови також доповненюэться роком перегляду; на момент написання статті це версія ECMAScript 2019, або скорочено ES2019.

Іншими словами, JavaScript або JS, який працює у вашому браузері або в Node.js, є *однією з* реалізацій стандарту ES2019.

| ПРИМІТКА: |
| :--- |
| Не використовуйте такі терміни, як "JS6" або "ES8", для позначення мови. Дехто так робить, але ці терміни лише посилюють плутанину. Слід дотримуватися назви "ES20xx" або просто "JS". |

Як би ви не називали цю мову - JavaScript, JS, ECMAScript або ES2019, це точно не варіант мови Java!

> "Java is to JavaScript as ham is to hamster." --Jeremy Keith, 2009" - Джеремі Кіт, 2009
Гра слів, яку приблизно можна перекласти так: "Java має таке ж відношення до JavaScript, як осел до оселедця".

## Специфікація мови

Я згадував TC39 - технічний координацыйний комітет, який керує JS. Його основним завданням є управління офіційною специфікацією мови. Члени комітету регулярно збираються для голосування щодо будь-яких узгоджених змін, які потім подають до ECMA, організації зі стандартизації.

Синтаксис та поведінка JS визначені у специфікації ES.

Версія ES2019 є 10-ю версією специфікації з мажорним номером з моменту створення JS у 1995 році, тому в офіційній URL-адресі специфікації на сайті ECMA ви знайдете "10.0":

https://www.ecma-international.org/ecma-262/10.0/

До складу комітету TC39 входить від 50 до 100 осіб з широкого кола компаній, що зацікавлені у розвитку Вебу, таких як розробники браузерів (Mozilla, Google, Apple) та виробники пристроїв (Samsung тощо). Всі члени комітету працюють на волонтерських засадах, хоча багато хто з них є працівниками вище згаданих компаній, і тому за виконання обов'язків в комітеті вони можуть отримувати часткову компенсацію.

TC39 збирається приблизно раз на місяць, як правило, три дні, щоб переглянути роботу, виконану членами з часу останнього засідання, обговорити питання та проголосувати за пропозиції. Місце проведення засідань чергуються між компаніями-членами комітету, які бажають прийняти у себе засідання.

Усі пропозиції TC39 проходять процес з п'яти етапів. Авжеж відлік, починається з 0, ми ж програмісти! Тож етапи мають номери від 0 до 4. Більше про процес можна прочитати тут: https://tc39.es/process-document/

Етап 0 приблизно означає, що хтось із TC39 вважає певну ідею непоганою і планує взяти участь в роботі над нею. Це означає, що безліч ідей, які пропонують особи, які не є членами TC39, за допомогою неформальних засобів, таких як соціальні медіа чи публікації в блогах, насправді ще не досягли Етапу 0. Щоб вважати Етап 0 розпочатим, потрібно знайти члена TC39, який погодиться відстоювати вашу пропозицію.

Як тільки пропозиція досягне Етапу 4, вона може бути включена до наступного щорічного перегляду мови. Проходження усіх цих етапів може тривати від кількох місяців до кількох років.

Усі пропозиції обговорюються відкрито у репозиторії TC39 Github: https://github.com/tc39/proposals

Будь-хто може взяти участь у цих публічних обговореннях та у процесі роботи над пропозиціями, однак лише члени TC39 можуть відвідувати засідання та голосувати за пропозиції чи зміни. Отже, насправді голос члена TC39 має велику вагу в тому, куди розвиватиметься JS.

Попри деякі усталені і прикро увічнені міфи, жодних версій JavaScript не існує. Існує лише **один JS**, офіційний стандарт, який підтримується TC39 та ECMA.

На початку 2000-х років, коли Microsoft створив шляхом зворотної розробки власну (і не зовсім сумісну зі специфікацією) версію JS під назвою "JScript", фактично існували кілька версій JS. Ті часи давно минули, тому сьогодні заявляти таке про JS є неактуальним і неточним.

 При розробці власних реалізацій JS усі основні браузери та виробники пристроїв зобов'язуються дотримуватися цієї єдиної центральної специфікації. Звичайно, рушії реалізують певні функції в різний час. Але ніколи не повинно бути так, щоб рушій v8 (JS-рушій у Chrome) реалізовував зазначену функцію інакше або несумісно у порівнянні з рушієм SpiderMonkey (рушій JS Mozilla).

Це означає, що ви можете вивчити **один JS** і покладатися на нього скрізь.

### Веб керує усім (усім JS-ом)

Масив середовищ, у яких можна запустити JS, постійно розширюється (від браузерів до серверів (Node.js), роботів, лампочок і так далі), але єдиним середовищем, яке керує JS, є Веб. Іншими словами, те, як реалізується JS для веббраузерів, є, по суті, єдиною реальністю, яка має значення.

Здебільшого JS, визначений у специфікації, і JS, який працює в браузерних рушіях JS, однаковий. Але є деякі відмінності, які необхідно враховувати.

Іноді специфікація JS диктує якусь нову або вдосконалену поведінку, і все ж це не буде точно відповідати тому, як вона працює в браузерних рушіях JS. Така невідповідність є історичною: рушії JS мали понад 20 років видимої поведінки навколо граничних випадків, на які покладається веб. Таким чином, іноді рушії JS відмовляються відповідати вимогам специфікації, оскільки це порушить наявний контент Вебу.

У цих випадках часто TC39 відступає і погоджується увідповіднити специфікацію до реальності Вебу. Наприклад, TC39 планував додати метод `contains(..)` до масивів, але було виявлено, що це ім'я конфліктує зі старими JS-фреймворками, які все ще використовуються на деяких сайтах, тому назву змінили на неконфліктну `includes(..)`. Те ж саме спричинило трагікомічну кризу JS-спільноти, яку назвали "smooshgate", коли запланований метод `flatten (..)` з часом був перейменований на `flat (..)`.

Але іноді TC39 вирішує, що специфікація не можу відступитися від якогось пункту, хоча малоймовірно, що JS-рушії у браузерах коли-небудь будуть дотримуватися цього пункта.

Що робити? Додаток B, "Додаткові функції ECMAScript для веббраузерів". [^ SpecApB] Специфікація JS містить цей додаток, щоб деталізувати всі відомі невідповідності між офіційною специфікацією JS та реальним JS у Вебі. Іншими словами, це винятки, дозволені *лише* для веб-JS; інші середовища JS повинні дотримуватися букви закону.

Розділи B.1 та B.2 охоплюють *доповнення* до JS (синтаксис та програмні інтерфейси), які знову ж таки, з історичних причин, включає вебверсія JS, але які TC39 не планує формально описувати як частину ядра JS. Приклади включають вісімкові літерали з префіксом `0`, глобальні утиліти `escape (..)`/`unescape (..)`, рядкові "помічники", такі як `anchor (..)` та `blink ()`, і метод RegExp `compile (..)`.

Розділ B.3 включає деякі конфлікти, коли код може працювати як у вебрушіях, так і в рушіях інших середовищ, але поведінка *може* помітно відрізнятися, що призводить до різних результатів. Більшість перелічених змін стосуються ситуацій, які позначені як ранні помилки у строгому режимі виконання("strict mode").

Додаток B перелічує деякі неочевидні випадки, що трапляються не дуже часто, але все ж корисно уникати цих конструкцій для безпеки коду у майбутньому. Де тільки можливо, дотримуйтесь специфікації JS і не покладайтесь на поведінку, яка застосовується лише у JS-рушіях для певних середовищ.

### Не все те JS...

Чи є цей код програмою на JS?

```js
alert("Hello, JS!");
```

Залежить від вашої точки зору. Функція `alert (..)` не включена до специфікації JS, але *реалізована* у всіх вебсередовищах, що підтримують JS. Проте в Додатку B ви її не знайдете, то як це розуміти?

Різні JS-середовища (наприклад, JS-рушії браузера, Node.js тощо) додають до глобальної області видимості ваших JS-програм програмні інтерфейси(API), що надають доступ до специфічних для цього середовища можливостей, як-от можливість виводити спливаюче вікно з попередженням в браузері користувача.

Насправді чимало програмних інтерфейсів, що дуже схожі на JS, наприклад, `fetch (..)`, `getCurrentLocation (..)` та `getUserMedia (..)`, насправді є веб-API, схожими на JS. Натомість у Node.js ми можемо отримати доступ до сотень методів API з різних вбудованих модулів, наприклад `fs.write (..)`.

Іншим поширеним прикладом є `console.log (..)` і всі інші методи `console. *`. Вони не вказані в специфікації JS, але через їх універсальну корисність визначені майже в кожному JS-середовищі, згідно з приблизно узгодженим консенсусом.

Отже, JS не визначає `alert (..)` і `console.log (..)`. Але вони *схожі* на JS. Вони є функціями та об'єктними методами і вони відповідають правилам синтаксису JS. Їхню поведінку контролює середовище, що запустило JS-рушій, але на поверхні вони, безумовно, повинні зважати на JS, щоб мати можливість грати на його полі.

Більшість відмінностей між браузерами, на які люди скаржаться, коли говорять про неконсистентність JS, насправді пов'язані з різницею в тому, як працює певна поведінка в певному середовищі, а не в тому, як працює сам JS.

Отже, виклик `alert (..)` — це JS, але сам `alert` насправді є лише гостем, а не частиною офіційної специфікації JS.

### Не завжди JS

Консоль або REPL (Read-Evaluate-Print-Loop, цикл читання-обчислення-друк) в інструментах розробника (dev tools) вашого браузера або Node на перший погляд здається досить звичайним JS-середовищем. Але насправді це не так.

Інструменти розробника це, власне, інструменти для розробників. Їх головне призначення - полегшити життя розробникам. Вони надають пріоритет приємному розробницькому досвіду (DX, developer experience). Точно і чисто відбивати всі нюанси поведінки JS за специфікацією не є метою таких інструментів. Таким чином, існує безліч особливостей поведінки, які можуть видатися неочікуваними, якщо ви розглядаєте консоль як *чисте* JS-середовище.

До речі, ця зручність це добре! Я радий, що інструменти розробника полегшують життя розробників! Я радий, що у нас є приємні принади UX, такі як автодоповнення імен змінних або властивостей. Я просто хочу привернути увагу до того, що ми не можемо і не повинні очікувати, що такі інструменти *завжди* чітко дотримуються того, як працюють  JS-програми, тому що вони існують не для цього.

Оскільки такі інструменти відрізняються за поведінкою у різних браузерах і оскільки вони змінюються (іноді досить часто), в цьому тексті я не збираюся вказувати конкретні деталі, тим самим забезпечуючи швидке застаріння тексту цієї книги.

Але все ж таки я натякну на деякі приклади дивної поведінки, які можна було спостерігати в різні моменти в різних консольних середовищах JS, щоб підкріпити міркування, що з цими інструментами не вато очікуати нативної поведінки JS:

* Чи створює оголошення з `var` або `function` на верхньому рівні так званої глобальної області видимості консолі  реальну глобальну змінну, а також віддзеркалену одноіменну властивість на `window`, і навпаки.

*  Що відбувається з безліччю оголошень `let` і` const` у глобальній області видимості верхнього рівня.

* Коли ви вводите `"use strict";` в одному рядку (натискаючи` <enter> `після), чи вмикається строгий режим для решти сеансу консолі, як це робиться в першому рядку файлу .js, а також чи можна використовувати `"use strict";` після "першого рядка" і все одно переходити до строгого режиму для цього сеансу.

* Як працює у нестрогому режимі прив'язка `this` за замовчуванням для викликів функцій та чи буде глобальний об'єкт містити очікувані глобальні змінні.

* Принцип роботи підняття (див. Книгу 2, *Області видимості та замикання*) у коді на кілька рядків.

* ...та декілька інших

Консоль розробника не намагається удавати JS-компілятор, який обробляє введений код так само, як JS-рушій обробляє файл .js. Вона намагається полегшити вам швидке введення кількох рядків коду та негайний перегляд результатів. Це абсолютно різні варіанти використання, і тому нерозумно очікувати, що один інструмент обробляє обидва випадки однаково.

Не думайте, що поведінка, яку ви бачите в консолі розробника, є відображенням *точної* буквальної семантики JS; для цього прочитайте специфікацію. Натомість думайте про консоль як про середовище, що просто вміє виконувати JS. Це корисно саме по собі.

## Багато облич

Термін "парадигма" в контексті мови програмування описує спосіб мислення в широкому сенсі та підход до структурування коду. У рамках парадигми існує безліч варіацій стилю та форми, які відрізняють програми, включаючи незліченну кількість різних бібліотек та фреймворків, що залишають свій унікальний відбиток на коді.

Але незалежно від індивідуального стилю програми, майже завжди з першого погляду можна визначити парадигми.

Зазвичай на рівні парадигми код розподіляють на процедурний, об'єктно-орієнтований (або класово-орієнтований) та функційний:

* Процедурний стиль організовує код в лінійній прогресії зверху вниз за допомогою заздалегідь визначеного набору операцій, зазвичай зібраних разом у зв'язні одиниці, які називаються процедурами.

* Об'єктно-орієнтований стиль організовує код, збираючи логіку та дані разом у блоки, які називаються класами.

* Функційний стиль організовує код у функції, що відрізняються від процедур чистими обчисленнями, та адаптації цих функцій як значення.

Парадигми не бувать ані правильними, ані хибними. Вони є орієнтаціями, які визначають, як підходити до проблем та рішень, як структурувати та підтримувати код.

Деякі мови сильно схильні до певної парадигми - C є процедурною мовою, Java / C ++ майже повністю орієнтована на класи, а Haskell - на функційне програмування.

Але багато мов підтримують шаблони організації коду, які можуть походити з різних парадигм і навіть змішують їх між собою. Так звані мультипардигменні мови пропонують надзвичайну гнучкість. У деяких випадках в одній програмі можуть навіть водночас бути прояви двох чи більше цих парадигм.

JavaScript - це, безумовно, багатопарадигменна мова. Ви можете писати процедурний, класовий або функційний код, і ви можете змінювати своє рішення ледь не кожного рядка, замість того, щоб вибрати один раз і не мати можливості передумати.

## Пряма та зворотна сумісність

Одним з найбільш фундаментальних принципів, яким керується JavaScript, є збереження *зворотної сумісності*. Багатьох людей бентежить прихований зміст цього терміна. Також його часто плутають з пов'язаним терміном *пряма сумісність*.

Давайте розберемося.

Зворотна сумісність означає, що як тільки щось визнається валідним JS-кодом, в мову більше не може бути внесено таких змін, що зроблять цей код невалідним. Код, написаний у 1995 р. - яким би примітивним чи обмеженим він не був! - повинен працювати і сьогодні. Як часто заявляють члени TC39, "не можна ламати Веб!"

Ідея полягає в тому, що JS-розробники можуть писати код із впевненістю, що цей код не перестане працювати через оновлення браузера. Це робить рішення вибрати JS для написання програми більш розумною та безпечною інвестицією на роки в майбутнє.

Ця "гарантія" - то не дрібниця. Підтримка зворотної сумісності, розтягнута на вже майже 25 років історії мови, створює величезний тягар та цілу низку унікальних задач. У світі обчислювальних технологій буде важко знайти багато інших прикладів такой відданості ідеї зворотної сумісності.

Варто пам'ятатми про ціну дотримання цього принципу. Вона складається з дуже високих вимог до змін чи розширення мови; будь-яке рішення фактично стає незворотним. Як тільки щось потрапляє в JS, його неможливо вийняти, оскільки це може зламати програми, навіть якщо іноді дуже, дуже сильно хочеться щось видалити!

З цього правила є кілька невеликих винятків. У JS відбулися деякі зміни, що порушили зворотну сумісність, але TC39 робить такі зміни дуже обережно. TC39 оцінює негативний вплив такої зміни за допомогою зібраних браузерами даних , а браузери в кінцевому підсумку приймають рішення і голосують, чи готові взяти на себе негатив від користувачів через дуже дрібну поломку, зважену на користь виправлення або вдосконалення деяких аспектів мови для багатьох інших сайтів і користувачів.

Такі зміни трапляються рідко і майже завжди стосуються граничних випадках використання, тому навряд чи будуть помітними на багатьох сайтах.

Порівняйте *зворотну сумісність* з аналогом, *прямою сумісністю*. Пряма сумісність означає, що включення в програму нового доповнення до мови не призведе до поломки цієї програми, якщо вона запускається у старому рушії JS. **JS не є прямо сумісним**, незважаючи на те, що багато хто цього бажає і навіть вірить, що цей міф відповідає дійсності.

HTML і CSS, навпаки, дотримуються прямої сумісності, але не зворотньої. Якщо ви викопали якийсь HTML або CSS, написані ще в 1995 році, цілком можливо, що сьогодні цей код геть не працюватим або працюватиме не належним чином. Але якщо ви використовуєте нову функцію, додану у 2019 році, в браузері 2010 року, сторінка не зламається - нерозпізнаний CSS / HTML пропускається, тоді як решта CSS / HTML буде оброблена коректно.

Пряма сумісність може здатися бажаною рисою мови програмування, але, як правило, це непрактично. Розмітка (HTML) або стилі (CSS) мають декларативний характер, тому набагато простіше "пропустити" нерозпізнані декларації з мінімальним впливом на розпізнані.

 Але якби рушій мови програмування вибірково пропускав інструкції або навіть цілі вирази, яких він не розуміє, це призвело б до хаосу і недетермінованості, оскільки неможливо переконатись, що наступна частина програми не залежить від пропущеного фрагменту.

Незважаючи на те, що JS не є і не може бути прямо-сумісною мовою, важливо визнати зворотну сумісність JS, включаючи стійкі переваги для Всесвітньої мережі та обмеження та труднощі, які вона спричиняє для JS.

### Стрибки через прогалини

Оскільки JS не дотримується прямої сумісності, завжди існує можливість розриву між валідним JS-кодом, і найстарішим рушієм, який ваш веб-сайт або програма має підтримувати. Якщо ви запускаєте програму, яка використовує можливості ES2019, на рушії 2016 року, швидше за все ваша програма зламається.

Якщо йдеться про новий синтаксис, програма, як правило, повністю не зможе скомпілюватися та запуститися, через синтаксичну помилку. Якщо функція є програмний інтерфейсом (наприклад, `Object.is (..)` з ES6), програма може запуститись до певної точки, але потім викинути виняток виконання та зупинитися, як тільки зустріне посилання на невідомий інтерфейс.

Чи означає це, що JS-розробники приречені завжди відставати від темпів прогресу, використовуючи лише той код, який зрозумілий найстарішим JS-рушіям тих середовищ, які вони повинні підтримувати? Зовсім ні!

Натомість це означає, що JS-розробники повинні докладати особливих зусиль, щоб заповнити цю прогалину.

Рішення для проблеми нового та несумісного синтаксису - транспіляція. Транспіляція - це винайдений спільнотою термін для опису використання інструменту для перетворення вихідного коду програми з однієї форми на іншу (але все ще як текстовий вихідний код). Як правило, проблеми прямої суміснсті, пов'язані з синтаксисом, вирішуються за допомогою транспілятора (найпоширенішим є Babel (https://babeljs.io)), що перетворює синтаксис цієї нової версії на еквівалентний старий синтаксис.

Наприклад, розробник може написати такий фрагмент коду:

```js
if (something) {
    let x = 3;
    console.log(x);
}
else {
    let x = 4;
    console.log(x);
}
```

Ось як виглядатиме код у дереві вихідного коду для цієї програми. Але під час створення файлу чи файлів для запуску на загальнодоступному веб-сайті транспілятор Babel може перетворити код таким чином:

```js
var x$0, x$1;
if (something) {
    x$0 = 3;
    console.log(x$0);
}
else {
    x$1 = 4;
    console.log(x$1);
}
```

Оригінальний фрагмент використовував `let` для створення блокової змінної `x` в обох гілках конструкції `if`, тобто як у `if`, так і у `else`, які не заважали одна одній. Еквівалентна програма (з мінімальною переробкою), яку Babel може створити, просто вирішує назвати дві різні змінні унікальними іменами, створюючи однаковий результат, коли імена не конфліктують.

| ПРИМІТКА: |
| :--- |
| Ключове слово `let` було додано до мови разом з ES6 (у 2015 році). Попередній приклад транспіляції мав би застосовуватися лише в тому випадку, коли застосунку потрібно працювати в середовищі JS, що підтримує попередню ES6. Приклад наведено лише для простоти ілюстрації. Коли стандарт ES6 тільки вийшов, потреба в такій транспіляції була досить поширеною, але в 2020 році набагато рідше виникає потреба підтримувати середовища, що не підтримують ES6. Таким чином, визначення "цільової мови", яка використовується для транпіляції, є розсувним вікном, яке зміщується вгору лише тоді, коли приймаються рішення припинити підтримку якогось старого браузера або рушія. |


Ви можете задатися питанням: навіщо взагалі ускладнювати собі життя використанням інструменту для перетворення нової версії синтаксису на стару? Чи не могли б ми просто написати дві змінні, використовуючи ключове слово `let`? Причина полягає в тому, що розробникам наполегливо рекомендується використовувати найновішу версію JS, щоб їх код був чистим та найбільш ефективно передавав свої ідеї.

Розробники повинні зосередитись на написанні чистих нових форм синтаксису, і нехай інструменти подбають про створення сумісної з перевагами версії цього коду, яка підходить для розгортання та запуску в найстаріших підтримуваних середовищах JS.

### Заповнення прогалин

Якщо проблема прямої сумісності пов'язана не з новим синтаксисом, а, скоріше, з відсутнім методом програмного інтенфейсу, який був нещодавно доданий, найпоширенішим рішенням є надання визначення для цього відсутнього методу, який діє так, ніби старе середовище це вже було визначено в природі. Цей шаблон називається "поліфіл" (polyfil),він же shim ("шім").

Розглянемо такий код:

```js
// getSomeRecords() returns us a promise for some
// data it will fetch
var pr = getSomeRecords();

// show the UI spinner while we get the data
startSpinner();

pr
.then(renderRecords)   // render if successful
.catch(showError)      // show an error if not
.finally(hideSpinner)  // always hide the spinner
```

Цей код використовує метод `finally(..)` на прототипі промісу, що вуб доданий у ES2019. Якби цей код запустили у середовищі до ES2019, метод `finally(..)` не існував би, і сталася б помилка.

Поліфіл для `finally(..)` в середовищах до ES2019 може виглядати так:

```js
if (!Promise.prototype.finally) {
    Promise.prototype.finally = function f(fn){
        return this.then(
            function t(v){
                return Promise.resolve( fn() )
                    .then(function t(){
                        return v;
                    });
            },
            function c(e){
                return Promise.resolve( fn() )
                    .then(function t(){
                        throw e;
                    });
            }
        );
    };
}
```

| ПОПЕРЕДЖЕННЯ: |
| :--- |
| Код поліфіла `finally(..)` наведений як ілюстрація. Це спрощена та не повністю сумісна зі специфікацією версія. Не використовуйте цей поліфіл у своєму коді; завжди використовуйте надійний, офіційний поліфіл, де це можливо, наприклад, з колекції поліфілів та шимів ES-Shim. |

Оператор `if` захищає визначення поліфілу, запобігаючи його запуску у середовищі, де рушій JS вже визначив цей метод. У старих середовищах поліфіл визначається, але в нових середовищах оператор if тихо пропускається.

Транспілятори, такі як Babel, зазвичай визначають поліфіли, які вашому коду, і надають їх автоматично. Але іноді вам може знадобитися включити або визначити їх явно, подібно до фрагменту, який ми щойно розглядали.

Завжди пишіть код з використанням тих можливостей мови, що найкраще передають ваші думки та наміри. В загальному випадку це означає використання останньої стабільної версії JS. Уникайте негативного впливу на читабельність коду через спроби вручну компенсувати синтаксису або програмні інтерфейси, яких бракує. Інструменти існують саме для цього!

Транспіляція та поліфіли - це два високоефективних прийоми для усунення розриву між кодом, який використовує найновіші стабільні можливості мови, та старими середовищами, які сайт чи застосунок все ще мають підтримувати. Оскільки JS не збирається припиняти вдосконалення, цей розрив ніколи не зникне. Обидва методи повинні бути прийняті як стандартна частина виробничого ланцюжка кожного проєкту на JS.

## А що в інтерпретації?

Довго обговорюване питання щодо коду, написаного на JS: це інтерпретований скрипт чи скомпільована програма? Здається, думка більшості полягає в тому, що JS - це інтерпретована (скриптова) мова. Але правда складніша.

Впродовж майже всієї історії мов програмування "інтерпретовані" та "скриптові" мови вважалися нижчими за статусом у порівнянні з мовами, що компілюються. Причин для такого негативного ставлення чимало, включаючи уявлення про відсутність оптимізації продуктивності, а також неприязнь до певних мовних характеристик, таких як динамічна типізація, яку скриптові мови використавують замість "більш зрілої" статичної типізації.

Мови, які вважаються "компільованими", як правило, створюють переносне (двійкове) представлення програми, яке розповсюджується для подальшого виконання. Оскільки з JS ми дійсно не спостерігаємо такого, бо ми розповсюджуємо вихідний код, а не двійкову форму, багато хто стверджує, що це виключає JS із категорії мов, що компілюються. Насправді за останні кілька десятиліть модель розповсюдження "виконуваної" форми програми стала значно біль різноманітною, а також менш актуальною; щодо самого питання, то насправді не так вже й важливо, в якій формі розповсюджують програми.

Ці необґрунтовані претензії та критику слід відкинути. Справжня причина, коли важливо мати чітке уявлення про те, чи інтерпретується або компілюється JS, пов’язана з природою способу обробки помилок.

Раніше код на скриптових або інтерпретованих мовах виконувався найчастіше зверху вниз рядок за рядком; як правило, немає початкового проходу через програму для її обробки до початку виконання (див. рисунок 1).

<figure>
    <img src="images/fig1.svg" width="650" alt="Interpreting a script to execute it" align="center">
    <figcaption><em>Fig. 1: Interpreted/Scripted Execution</em></figcaption>
    <br><br>
</figure>

У скриптових або інтерпретованих мовах помилка у п'ятому рядку програми не буде виявлена, поки не будуть виконані рядки з 1 по 4. Примітно, що помилка в рядку 5 може бути пов’язана з умовою часу виконання, наприклад, якоюсь змінною чи значенням, що має невідповідне значення для операції, або через неправильний вираз чи команду на цьому рядку. Залежно від контексту перенесення обробки помилок на рядок, на якому виникає помилка, може бути бажаним або небажаним ефектом.

Порівняйте це з мовами, які проходять етап обробки, як правило, так званий парсинг, до початку виконання, як показано на малюнку 2:

<figure>
    <img src="images/fig2.svg" width="650" alt="Parsing, compiling, and executing a program" align="center">
    <figcaption><em>Fig. 2: Parsing + Compilation + Execution</em></figcaption>
    <br><br>
</figure>

У цій моделі обробки помилкова команда (наприклад, з порушенням синтаксису) у рядку 5 буде перехоплена на етапі парсингу, перш ніж розпочнеться будь-яке виконання, і програма не запуститься. Для лову синтаксичних (так званих "статичних") помилок, як правило, бажано знати про них перед будь-яким частковим виконанням.

Тож що спільного у мов, що парсяться, та «компільованих» мов? По-перше, всі компільовані мови парсяться. Отже, парсинг - це вже половина роботи з компіляції. У класичній теорії компіляції останнім кроком, що залишився після парсингу, є генерація коду, тобто створення виконуваної форми.

Як тільки будь-яку програму-джерело буде повністю розпарсено, дуже часто, що її подальше виконання, в тій чи іншій формі, включатиме переклад із розпарсеної форми програми - зазвичай її називають абстрактним синтаксичним деревом (AST) - на цю виконувану форми.

Іншими словами, мови, що парсяться, зазвичай також виконують генерацію коду перед виконанням, тому не так вже й важко стверджувати, що ідейно вони компільовані мови.

Вихідний код JS парситься перед виконанням. Специфікація вимагає цього, оскільки вона вимагає повідомляти про "ранні помилки" - статистично визначені помилки в коді, такі як подвоєння імені параметра, перед початком виконання коду. Ці помилки неможливо розпізнати без парсингу коду.

Отже **JS парситься**, але чи він *компілюється*?

Скоріш так, ніж ні. Розпарсений JS перетворюється на оптимізовану (двійкову) форму, і цей "код" згодом виконується (рис. 2); рушій зазвичай не переходить назад у режим послідовного виконання (як на малюнку 1) після того, як закінчить усю важку роботу з синтаксичного аналізу - більшість мов / рушіїв цього не робить, оскільки це буде дуже неефективно.

Точніше кажучи, ця "компіляція" створює свого роду двійковий байт-код, який потім передається на виконання віртуальній машині JS. Деякі люблять стверджувати, що ця ВМ "інтерпретує" байт-код. Але тоді це означає, що Java, а також десяток інших мов на базі JVM інтерпретуються, а не компілюються. Звичайно, це суперечить типовому твердженню про те, що Java та подібні їй - це компільовані мови.

Цікаво, що хоча Java та JavaScript - це дуже різні мови, питання інтерпретації чи компіляції між ними досить тісно пов’язане!

Інша складність полягає в тому, що рушії JS можуть використовувати декілька проходів обробки / оптимізації JIT (Just-In-Time) згенерованого коду (після синтаксичного аналізу), які знову можна обгрунтовано позначити або "компіляцією", або "інтерпретацією" залежно від точки зору. Насправді те, що відбувається під капотом рушія JS, фантастично складна річ.

То до чого зводяться ці дрібні деталі? Зробіть крок назад і розгляньте весь потік вихідної програми JS:

1. Після того, як програма залишає редактор розробника, її транспілює Babel, потім збирає Webpack (і, можливо, ще півдюжини інших процесів збірки), а потім в зовсім іншій формі вона потрапляє до рушія JS.

2. Рушій JS парсить код на AST.

3. Потім рушій перетворює цей AST на своєрідний байт-код, двійкове проміжне представлення (IR), яке потім уточнюється / трансформується ще більше оптимізуючим компілятором JIT.

4. Нарешті, віртуальна машина JS виконує програму.

Візуалізуємо ці кроки:

<figure>
    <img src="images/fig3.svg" width="650" alt="Steps of JS compilation and execution" align="center">
    <figcaption><em>Fig. 3: Parsing, Compiling, and Executing JS</em></figcaption>
    <br><br>
</figure>

Чи обробляється JS більше як інтерпретований скрипт рядок за рядком, як на малюнку 1, або він обробляється більше як компільована мова, яка обробляється спочатку від одного до кількох проходів, перед виконанням (як на малюнках 2 та 3) ?

Я думаю, зрозуміло, що за духом, якщо не на практиці, **JS - це компільована мова**.

І знову ж таки, важлива особливість полягає в тому, що, оскільки JS компілюється, ми отримуємо інформацію про статичні помилки (наприклад, неправильний синтаксис) перед тим, як виконати наш код. Це істотно інша модель взаємодії, ніж ми отримуємо з традиційними скриптовими програмами, і, можливо, корисніша!

### Web Assembly (WASM)

Основною проблемою, яка мотивувала значну частину розвитку JS, є продуктивність, як швидкість парсингу / компіляції JS, так і швидкість виконання цього скомпільованого коду.

У 2013 році інженери з Mozilla Firefox продемонстрували порт ігрового рушія Unreal 3 з C на JS. Можливість запуску цього коду на рушії JS браузера з повною продуктивністю 60 кадрів в секунду була заснована на наборі оптимізацій, які механізм JS міг би виконати спеціально, оскільки версія JS коду рушія Unreal використовувала стиль коду, який надавав перевагу підмножині JS, названа "ASM.js".

Ця підмножина є валідним JS, написаним дещо незвичним чином, але який передає певну важливу інформацію про типи рушієві, що дозволяє йому робити ключові оптимізації. ASM.js було введено як один із способів подолання тиску на продуктивність виконання JS.

Але важливо зауважити, що ASM.js ніколи не був кодом, авторством якого були розробники, а скоріше подання програми, яка була перекладена з іншої мови (наприклад, C), де ці введені "анотації" автоматично вставлялися оснащення.

Через кілька років після того, як ASM.js продемонстрував валідність створених інструментальних версій програм, які можуть бути оброблені JS-рушієм більш ефективно, інша група інженерів (також, спочатку з Mozilla) випустила Web Assembly (WASM).

WASM схожий на ASM.js тим, що його початковий намір полягав у забезпеченні шляху для програм, що не належать до JS (C тощо), які слід перетворити у форму, яка може працювати в рушії JS. На відміну від ASM.js, WASM вирішив додатково обійти деякі притаманні затримки при синтаксичному аналізі / компіляції JS перед тим, як програма зможе виконати, представляючи програму у формі, яка абсолютно не схожа на JS.

WASM - це формат представлення, більш схожий на Assembly (звідти його назва), який може оброблятися рушієм JS, пропускаючи синтаксичний аналіз / компіляцію, який зазвичай робить рушій JS. Синтаксичний аналіз / компіляція програми, орієнтованої на WASM, відбувається заздалегідь (AOT, ahead-of-time); що розповсюджується, це програма в двійковому пакеті, готова для роботи рушія JS з мінімальною обробкою.

Початковою мотивацією для WASM було явно потенційне покращення продуктивності. Незважаючи на те, що це продовжує залишатися в центрі уваги, WASM додатково мотивоване бажанням привнести більше паритету для мов, які не є JS, на веб-платформу. Наприклад, якщо така мова, як Go, підтримує багатопоточне програмування, а JS , WASM пропонує можливість перетворення такої програми на Go у форму, яку може зрозуміти рушій JS, без необхідності реалізації потоків у JS.

Іншими словами, WASM знімає тиск на додавання до JS функцій, які здебільшого / виключно призначені для використання у програмах з інших мов. Це означає, що про розвиток функцій JS можна судити (за допомогою TC39), не збиваючись на інтереси / вимоги в інших мовних екосистемах, при цьому дозволяючи цим мовам мати життєздатний шлях до Інтернету.

Інший погляд на WASM, що виникає, що цікаво, навіть не пов’язаний безпосередньо з Інтернетом (W). WASM перетворюється на своєрідну міжплатформенну віртуальну машину (VM), де програми можуть бути скомпільовані один раз і запущені в безлічі різних системних середовищ.

Отже, WASM не тільки для Інтернету, а WASM також не є JS. За іронією долі, навіть незважаючи на те, що WASM працює на рушії JS, мова JS є однією з найменш придатних мов для джерел програм WASM, оскільки WASM значною мірою покладається на статичну типізацію. Навіть TypeScript (TS) - очевидно, статичні типи JS + - не зовсім придатний (як зараз) для транспіляції до WASM, хоча мовні варіанти, такі як AssemblyScript, намагаються подолати розрив між JS / TS і WASM.

Ця книга не стосується WASM, тому я не буду витрачати більше часу на її обговорення, окрім як на останню думку. *Деякі* люди припускають, що WASM вказує на майбутнє, де JS вирізається або зводиться до використання тільки у Веб. Ці люди часто мають негативні почуття щодо JS і хочуть замінити його якоюсь іншою мовою - будь-якою іншою! Оскільки WASM дозволяє іншими мовами працювати на рушії JS, на перший погляд це не зовсім фантастика.

Але дозвольте просто сказати: WASM не замінить JS. WASM значно збільшує те, що може зробити у Веб (включаючи розширення можливостей JS). Це чудова річ, цілком ортогональна тому, чи будуть деякі люди використовувати це як можливість не писати на JS.

## Строго кажучи

Ще в 2009 році, коли вийшов ES5, JS додав опцію *строгий режим* для заохочення кращих програм на JS.

Переваги строгого режиму значно перевищують витрати, але старі звички важко вмирають, і інерцію існуючих (інакше "застарілих") основ коду насправді важко змінити. На жаль, більш ніж через 10 років опціональність строгого режиму  означає, що він все ще не обов'язковим для програмістів JS.

Навіщо потрібний строгий режим? Строгий режим не слід розглядати як обмеження, а скоріше як керівництво найкращим способом зробити те, щоб оушій JS мав найкращі шанси на оптимізацію та ефективний запуск коду. Найчастіше на JS-кодом працюють цілі команди розробників, тому строгий режим (разом із інструментами, такими як лінтери!) Часто допомагає співпраці над кодом, зокрема униканню деяких найбільш проблемних помилок, які проскакують у нестрогому режимі.

Найбільш строгі режими керування мають форму ранніх помилок, тобто помилки, які не є суто синтаксичними помилками, але все одно видаються під час компіляції (до запуску коду). Наприклад, строгий режим забороняє однакові імена двох параметрів функції і призводить до ранньої помилки. Деякі інші відмінності строгого режиму можна спостерігати лише під час виконання, наприклад, як `this` за замовчуванням має значення `undefined` замість глобального об'єкта.

Замість того, щоб битися і сперечатися у строгому режимі, як дитина, яка просто хоче кинути виклик тому, що батьки скажуть не робити, найкраще мислення полягає в тому, що строгий режим - це як лінтер, який нагадує вам, як слід писати JS *, щоб мати найвищу якість та найкращі шанси на продуктивність. Якщо ви відчуваєте себе в наручниках, намагаючись обійти строгий режим, це має бути для вас знаком того, що варто зробити крок назад та переглянути весь підхід.

Строгий режим вмикається для кожного файлу спеціальною прагмою (до нього не допускається нічого, крім коментарів / пробілів):

```js
// only whitespace and comments are allowed
// before the use-strict pragma
"use strict";
// the rest of the file runs in strict mode
```

| ЗАСТЕРЕЖЕННЯ: |
| :--- |
| Слід пам’ятати, що навіть заблукалі крапка з комою перед прагмою "use strict" зроблять прагму марною; помилок не виникає, оскільки дійсний JS має строковий літеральний вираз у позиції оператора, але він також безшумно *не* увімкне строгий режим! |

Строгий режим також можна ввімкнути для кожної функції з точно однаковими правилами щодо оточення:

```js
function someOperations() {
    // whitespace and comments are fine here
    "use strict";

    // all this code will run in strict mode
}
```

Цікаво, що якщо у файлі ввімкнено строгий режим, прагми строгого режиму на рівні функції заборонені. Отже, доведеться вибрати щось одне.

**Єдиною** вагомою причиною використання строгого режиму для окремої функції є випадок, коли ви перетворюєте існуючий файл програми з нестрогого режиму і зміни доводиться вносити поетапно. В іншому випадку набагато краще просто увімкнути строгий режим для всього файлу чи програми.

Багато хто питає, чи коли-небудь у JS строгий режим буде ввімкнено за замовчуванням. Відповідь - майже напевно, що ні. Як ми вже обговорювали щодо зворотної сумісності, якщо оновлення рушія JS почало припускати, що код був у строгому режимі, навіть якщо він не позначений як такий, цілком можливо, що цей код зламається в результаті увімкннея строгого режиму.

Однак є кілька факторів, які зменшують майбутній вплив невідосоті.

У сукупності строгий режим - це фактично режим за замовчуванням, хоча технічно він не є дефолтним.

З одного боку, практично весь транспільований код потрапляє в строгий режим, навіть якщо оригінальний вихідний код не написаний як такий. Більшість JS-коду у реальниз умовах використання транспілюється, тож це означає, що більшість JS вже дотримуються строгого режиму. Це припущення можна скасувати, але для цього вам дійсно докласти сили, тому це малоймовірно.

Більше того, відбувається великий зсув у бік створення більшості нового коду на JS із використанням формату  ES6-модулів.  ES6-модулі передбачають строгий режим, тому весь код у таких файлах автоматично за замовчуванням встановлюється на строгий режим.



## Визначено

JS - це реалізація стандарту ECMAScript (версія ES2019 станом на момент написання книги), який керується комітетом TC39 та приймається ECMA. Він працює у браузерах та інших середовищах JS, таких як Node.js.

JS - мультипарадигменна мова, тобто синтаксис та можливості дозволяють розробнику поєднувати концепції з різних основних парадигм, таких як процедурна, об’єктно-орієнтована (OO / класи) та функційна (FP), а також і відхилятися від них та модифікувати за потребою та переробляти.

JS - це компільована мова, тобто інструменти (включаючи рушій JS) обробляють і перевіряють програму до її запуску та повідомляють про будь-які помилки.

Нарешті ми визначилися з тим, що таке мова JS, тож давайте почнемо знайомитися з її тонкощами.

[^specApB]: ECMAScript 2019 Language Specification, Appendix B: Additional ECMAScript Features for Web Browsers, https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers (latest as of time of this writing in January 2020)
